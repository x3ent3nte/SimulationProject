#version 460
#extension GL_ARB_separate_shader_objects : enable

#define X_DIM 1

layout (local_size_x = X_DIM, local_size_y = 1, local_size_z = 1) in;

struct Agent {
    uint typeId;
    int playerId;
    vec3 position;
    vec3 velocity;
    vec3 acceleration;
    vec3 target;
    vec3 rotationalVelocity;
    vec4 rotation;
    float radius;
    float mass;
    float life;
};

struct Collision {
    uint one;
    uint two;
    float time;
};

layout (std430, binding = 0) buffer bufferAgents {
    Agent agents[];
};

readonly layout (std430, binding = 1) buffer bufferCollisions {
    Collision collisions[];
};

float cosineSimilarity(vec3 a, vec3 b) {
    const float magMult = length(a) * length(b);
    if (magMult == 0.0f) {
        return 0.0f;
    }

    return dot(a, b) / magMult;
}

vec3 projection(vec3 u, vec3 v) {
    const float magV = length(v);
    return (dot(u, v) / (magV * magV)) * v;
}

void main() {

    Collision col = collisions[0];

    Agent one = agents[col.one];
    Agent two = agents[col.two];

    const float oneMass = one.mass;
    const float twoMass = two.mass;

    const vec3 posDiff = two.position - one.position;
    const vec3 oneImpactVelocityPre = projection(one.velocity, posDiff);
    vec3 twoImpactVelocityPre = projection(two.velocity, -posDiff);

    const vec3 oneMomentumPre = oneImpactVelocityPre * oneMass;
    const vec3 twoMomentumPre = twoImpactVelocityPre * twoMass;
    const vec3 totalMomentumPre = oneMomentumPre + twoMomentumPre;

    const vec3 oneImpactVelocityPost = (((oneMass - twoMass) / (oneMass + twoMass)) * oneImpactVelocityPre) + (((2 * twoMass) / (oneMass + twoMass)) * twoImpactVelocityPre);
    const vec3 twoImpactVelocityPost = (totalMomentumPre - (oneImpactVelocityPost * oneMass)) / twoMass;

    one.velocity += (-oneImpactVelocityPre + oneImpactVelocityPost);
    two.velocity += (-twoImpactVelocityPre + twoImpactVelocityPost);

    one.life -= 4.0f;
    two.life -= 4.0f;

    agents[col.one] = one;
    agents[col.two] = two;
}
